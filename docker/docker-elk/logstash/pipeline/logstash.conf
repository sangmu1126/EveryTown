input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://mysql:3306/everytowndb?useLegacyDatetimeCode=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8"
    jdbc_user => "root"
    jdbc_password => "rootpassword"
    
    columns_charset => {
      "name" => "UTF-8"
      "category_large_name" => "UTF-8"
      "category_middle_name" => "UTF-8"
      "category_small_name" => "UTF-8"
      "dong" => "UTF-8"
      "address" => "UTF-8"
      "menu_names" => "UTF-8"
    }

    statement => "
      SELECT
        rest.*,
        UNIX_TIMESTAMP(rest.modified_at) AS unix_ts_in_secs,
        GROUP_CONCAT(rw.id ORDER BY rw.id ASC SEPARATOR '^&^') AS review_ids,
        GROUP_CONCAT(rw.nickname ORDER BY rw.id ASC SEPARATOR '^&^') AS review_nicknames,
        GROUP_CONCAT(rw.rating ORDER BY rw.id ASC SEPARATOR '^&^') AS review_ratings,
        GROUP_CONCAT(rw.content ORDER BY rw.id ASC SEPARATOR '^&^') AS review_contents,
        AVG(rw.rating) AS rating
      FROM(
        SELECT
          res.*,
          GROUP_CONCAT(m.name ORDER BY m.id ASC SEPARATOR '^&^') AS menu_names,
          GROUP_CONCAT(m.price ORDER BY m.id ASC SEPARATOR '^&^') AS menu_prices,
          GROUP_CONCAT(m.id ORDER BY m.id ASC SEPARATOR '^&^') AS menu_ids
        FROM(
          SELECT
            r.*,
            GROUP_CONCAT(rt.tag ORDER BY rt.id ASC SEPARATOR ' ') AS restaurant_tags
          FROM
            restaurant r
          LEFT JOIN
            restaurant_tag rt ON r.id = rt.restaurant_id
          GROUP BY
            r.id) AS res
        LEFT JOIN
          restaurant_menu m ON res.id = m.restaurant_id
        GROUP BY
          res.id) AS rest
      LEFT JOIN
        restaurant_review rw ON rest.id = rw.restaurant_id
      WHERE
        UNIX_TIMESTAMP(rest.modified_at) > :sql_last_value AND rest.modified_at < NOW()
      GROUP BY
        rest.id
    "

    jdbc_paging_enabled => true
    use_column_value => true
    tracking_column => "unix_ts_in_secs"
    tracking_column_type => "numeric"
    clean_run => false
    last_run_metadata_path => "/usr/share/logstash/metadata/restaurant/sql_last_value"
    schedule => "*/30 * * * * *"
    type => "restaurant"
  }
  
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://mysql:3306/everytowndb?useLegacyDatetimeCode=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8"
    jdbc_user => "root"
    jdbc_password => "rootpassword"
    
    columns_charset => {
      "name" => "UTF-8"
      "category_large_name" => "UTF-8"
      "category_middle_name" => "UTF-8"
      "category_small_name" => "UTF-8"
      "dong" => "UTF-8"
      "address" => "UTF-8"
      "menu_names" => "UTF-8"
    }

    statement => "
      SELECT
        pla.*,
        UNIX_TIMESTAMP(pla.modified_at) AS unix_ts_in_secs,
        GROUP_CONCAT(pr.id ORDER BY pr.id ASC SEPARATOR '^&^') AS review_ids,
        GROUP_CONCAT(pr.nickname ORDER BY pr.id ASC SEPARATOR '^&^') AS review_nicknames,
        GROUP_CONCAT(pr.rating ORDER BY pr.id ASC SEPARATOR '^&^') AS review_ratings,
        GROUP_CONCAT(pr.content ORDER BY pr.id ASC SEPARATOR '^&^') AS review_contents,
        AVG(pr.rating) AS rating
      FROM(
        SELECT
          pl.*,
          GROUP_CONCAT(m.name ORDER BY m.id ASC SEPARATOR '^&^') AS menu_names,
          GROUP_CONCAT(m.price ORDER BY m.id ASC SEPARATOR '^&^') AS menu_prices,
          GROUP_CONCAT(m.id ORDER BY m.id ASC SEPARATOR '^&^') AS menu_ids
        FROM(
          SELECT
            p.*,
            GROUP_CONCAT(pt.tag ORDER BY pt.id ASC SEPARATOR ' ') AS place_tags
          FROM
            place p
          LEFT JOIN
            place_tag pt ON p.id = pt.place_id
          GROUP BY
            p.id) AS pl
        LEFT JOIN
          place_menu m ON pl.id = m.place_id
        GROUP BY
          pl.id) AS pla
      LEFT JOIN
        place_review pr ON pla.id = pr.place_id
      WHERE
        UNIX_TIMESTAMP(pla.modified_at) > :sql_last_value AND pla.modified_at < NOW()
      GROUP BY
        pla.id
    "

    jdbc_paging_enabled => true
    use_column_value => true
    tracking_column => "unix_ts_in_secs"
    tracking_column_type => "numeric"
    clean_run => false
    last_run_metadata_path => "/usr/share/logstash/metadata/place/sql_last_value"
    schedule => "*/30 * * * * *"
    type => "place"
  }
    
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/mysql-connector-java-8.0.33.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://mysql:3306/everytowndb?useLegacyDatetimeCode=false&serverTimezone=Asia/Seoul&characterEncoding=UTF-8"
    jdbc_user => "root"
    jdbc_password => "rootpassword"

    statement => "
      SELECT
        c.*,
        UNIX_TIMESTAMP(c.modified_at) AS unix_ts_in_secs,
        GROUP_CONCAT(ct.tag ORDER BY ct.id ASC SEPARATOR ' ') AS chatroom_tags
      FROM(
        SELECT
          room.*,
          m.nickname
        FROM
          chat_room room
        LEFT JOIN
          member m ON room.member_id = m.id
        GROUP BY
          room.id) AS c
      LEFT JOIN
        chat_room_tag ct ON c.id = ct.chat_room_id
      WHERE
        UNIX_TIMESTAMP(c.modified_at) > :sql_last_value AND c.modified_at < NOW()
      GROUP BY
        c.id
    "

    jdbc_paging_enabled => true
    use_column_value => true
    tracking_column => "unix_ts_in_secs"
    tracking_column_type => "numeric"
    clean_run => false
    last_run_metadata_path => "/usr/share/logstash/metadata/chatroom/sql_last_value"
    schedule => "*/1 * * * * *"
    type => "chatroom"
  }
}

filter {
  if [type] == "restaurant" {
    mutate {
      add_field => {
        "location" => "%{latitude},%{longitude}"
      }
      remove_field => ["latitude", "longitude", "@version", "@timestamp", "unix_ts_in_secs"]
    }
    ruby {
      code => '
        menu_ids = event.get("menu_ids")&.split("^&^") || []
        menu_names = event.get("menu_names")&.split("^&^") || []
        menu_prices = event.get("menu_prices")&.split("^&^") || []

        menu = []

        menu_names.each_with_index do |name, index|
          menuItem = { "name" => name }
          price = index < menu_prices.size ? menu_prices[index].to_i : nil
          menuItem["price"] = price unless price.nil?
          menuItem["id"] = menu_ids[index].to_i
          menu.push(menuItem)
        end

        event.set("menu", menu)
        event.remove("menu_prices")
        event.remove("menu_ids")


        review_ids = event.get("review_ids")&.split("^&^") || []
        review_nicknames = event.get("review_nicknames")&.split("^&^") || []
        review_ratings = event.get("review_ratings")&.split("^&^") || []
        review_contents = event.get("review_contents")&.split("^&^") || []

        review = []

        review_ids.each_with_index do |id, index|
          reviewItem = { "id" => id }
          reviewItem["nickname"] = review_nicknames[index]
          reviewItem["rating"] = review_ratings[index].to_f
          reviewItem["content"] = review_contents[index]
          review.push(reviewItem)
        end

        event.set("review", review)
        event.remove("review_ids")
        event.remove("review_nicknames")
        event.remove("review_ratings")


        event.set("tag", "#{event.get("restaurant_tags")} default")
        event.remove("restaurant_tags")
      '
    }
  }

  if [type] == "place" {
    mutate {
      add_field => {
        "location" => "%{latitude},%{longitude}"
      }
      remove_field => ["latitude", "longitude", "@version", "@timestamp", "unix_ts_in_secs"]
    }
    ruby {
      code => '
        menu_ids = event.get("menu_ids")&.split("^&^") || []
        menu_names = event.get("menu_names")&.split("^&^") || []
        menu_prices = event.get("menu_prices")&.split("^&^") || []

        menu = []

        menu_names.each_with_index do |name, index|
          menuItem = { "name" => name }
          price = index < menu_prices.size ? menu_prices[index].to_i : nil
          menuItem["price"] = price unless price.nil?
          menuItem["id"] = menu_ids[index].to_i
          menu.push(menuItem)
        end

        event.set("menu", menu)
        event.remove("menu_prices")
        event.remove("menu_ids")


        review_ids = event.get("review_ids")&.split("^&^") || []
        review_nicknames = event.get("review_nicknames")&.split("^&^") || []
        review_ratings = event.get("review_ratings")&.split("^&^") || []
        review_contents = event.get("review_contents")&.split("^&^") || []

        review = []

        review_ids.each_with_index do |id, index|
          reviewItem = { "id" => id }
          reviewItem["nickname"] = review_nicknames[index]
          reviewItem["rating"] = review_ratings[index].to_f
          reviewItem["content"] = review_contents[index]
          review.push(reviewItem)
        end

        event.set("review", review)
        event.remove("review_ids")
        event.remove("review_nicknames")
        event.remove("review_ratings")


        event.set("tag", "#{event.get("place_tags")} default")
        event.remove("place_tags")
      '
    }
  }

  if [type] == "chatroom" {
    date {
      match => ["[created_at]", "UNIX"]
      target => "[created_at]"
      timezone => "Asia/Seoul"
    }
    date {
      match => ["[modified_at]", "UNIX"]
      target => "[modified_at]"
      timezone => "Asia/Seoul"
    }
    mutate {
      add_field => {
        "location" => "%{latitude},%{longitude}"
      }
      remove_field => ["latitude", "longitude", "@version", "@timestamp", "unix_ts_in_secs"]
    }
    ruby {
      code => '
        event.set("tag", "#{event.get("chatroom_tags")} default")
        event.remove("chatroom_tags")
      '
    }
  }
}

output {
  if [type] == "restaurant" {
    elasticsearch {
      hosts => "elasticsearch:9200"
      index => "restaurant"
      document_id => "%{id}"
    }
  }

  if [type] == "place" {
    elasticsearch {
      hosts => "elasticsearch:9200"
      index => "place"
      document_id => "%{id}"
    }
  }

  if [type] == "chatroom" {
    elasticsearch {
      hosts => "elasticsearch:9200"
      index => "chatroom"
      document_id => "%{id}"
    }
  }
  
  stdout {
    codec => rubydebug
  }
}
